<!DOCTYPE HTML>

<html>
	<head>
		<title>Generic Page - Industrious by TEMPLATED</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="" />
		<meta name="keywords" content="" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a class="logo" href="index.html">CURSO DE GOLANG</a>
				<nav>
					<a href="#menu">Menu</a>
				</nav>
			</header>

		<!-- Nav -->
			<nav id="menu">
				<ul class="links">
					<li><a href="generic.html">MÓDULO I</a></li>
					<li><a href="generic2.html">MÓDULO II</a></li>
					<li><a href="generic3.html">MÓDULO III</a></li>
				</ul>
			</nav>

		<!-- Heading -->
			<div id="heading" >
				<h1>MÓDULO  I: INICIANTE</h1>
			</div>

		<!-- Main -->
			<section id="main" class="wrapper">
				<div class="inner">
					<div class="content">
						<header>

							<h2>HISTÓRICO</h2>
						</header>
						<p>A linguagem de programação Go, também conhecida como GoLang, é uma linguagem moderna de código aberto que foi desenvolvida pelo Google. O trabalho no desenvolvimento do Go começou em 2007, e a primeira versão estável foi lançada em março de 2012. Desde então, a linguagem tem ganhado popularidade entre os desenvolvedores de software em todo o mundo. </p>
						<p>A criação do Go foi motivada pela insatisfação de alguns engenheiros do Google com as linguagens de programação existentes. Eles sentiram que muitas das linguagens disponíveis na época eram excessivamente complexas, lentas ou não atendiam às suas necessidades de desenvolvimento. Como resultado, eles decidiram criar uma nova linguagem que abordasse esses problemas. </p>
						<p>A equipe de desenvolvimento do Go, liderada por Robert Griesemer, Rob Pike e Ken Thompson, tinha como objetivo principal criar uma linguagem simples, eficiente e fácil de usar. Eles queriam que o Go fosse adequado para lidar com sistemas grandes e complexos, ao mesmo tempo que fornecesse uma sintaxe limpa e intuitiva.</p>
						<p>Em resumo, o GoLang surgiu como uma linguagem de programação moderna e eficiente, criada para abordar as limitações e desafios encontrados em outras linguagens. Com sua sintaxe clara, compilação rápida e suporte nativo a concorrência, o Go tem ganhado popularidade entre desenvolvedores que buscam uma experiência de programação mais simples e produtiva.</p>
						<hr />

							<h2>CARACTERÍSTICAS</h2>
						<p>A linguagem de programação Go, também conhecida como GoLang, possui várias características distintivas que a tornam uma escolha popular entre os desenvolvedores. Entre elas temos:</p>
						<h3>Simplicidade:</h3>
						<p>Uma das principais características do Go é a sua simplicidade. A sintaxe da linguagem foi projetada para ser limpa e concisa, evitando recursos complexos e desnecessários. Isso torna o Go fácil de aprender e ler, promovendo um código mais legível e compreensível.</p>
						<h3>Eficiência:</h3>
						<p>O Go é conhecido por sua eficiência. A compilação rápida da linguagem permite um desenvolvimento mais ágil, economizando tempo e recursos. Além disso, o Go foi projetado para fornecer um desempenho excepcional em tempo de execução, tornando-o adequado para a construção de aplicativos de alta performance.</p>
						<h3>Concorrência</h3>
						<p>A linguagem Go possui suporte nativo à concorrência. As goroutines, que são unidades leves de concorrência, permitem que os desenvolvedores escrevam programas paralelos de forma mais simples. Além disso, a biblioteca padrão do Go inclui mecanismos como canais (channels) para facilitar a comunicação e a sincronização entre goroutines, tornando a programação concorrente mais fácil e menos propensa a erros.</p>
						<h3>Coleta de lixo</h3>
						<p>O Go possui um coletor de lixo eficiente e automático, que gerencia a alocação e liberação de memória automaticamente. Isso permite que os desenvolvedores se concentrem mais na lógica do programa em vez de se preocuparem com a gerência manual de memória.</p>
						<h3>Segurança de tipos</h3>
						<p>O Go é uma linguagem estaticamente tipada, o que significa que as variáveis possuem tipos definidos em tempo de compilação. Essa abordagem ajuda a detectar erros de tipo em tempo de compilação, evitando muitos bugs comuns e melhorando a confiabilidade do código.</p>
						<h3>Portabilidade</h3>
						<p>O Go é altamente portável, sendo suportado em uma ampla gama de plataformas e sistemas operacionais. Isso permite que os desenvolvedores escrevam código uma vez e o executem em diferentes ambientes sem a necessidade de modificações significativas.</p>
						<h3>Ecossistema e comunidade</h3>
						<p>O Go possui um ecossistema crescente de bibliotecas e frameworks que abrangem diversos domínios, como desenvolvimento web, banco de dados, redes e muito mais. Além disso, a comunidade de desenvolvedores do Go é ativa e acolhedora, oferecendo suporte e recursos valiosos para ajudar os iniciantes e especialistas.</p>
						<p>Essas são apenas algumas das características que tornam o GoLang uma linguagem de programação atraente. Combinando simplicidade, eficiência, concorrência nativa e segurança de tipos, o Go oferece uma abordagem moderna para o desenvolvimento de software, tornando-o uma opção popular para uma ampla gama de aplicativos e projetos.</p>
						<hr />

							<h2>INSTALAÇÃO</h2>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/rG97QzaKTcc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
						<hr />

							<h2>ESTRUTURAS DE CONTROLE</h2>
						<h3>LOOPS</h3>
						<p>O loop "for" é a principal estrutura de repetição em GoLang. Ele permite repetir um bloco de código várias vezes com base em uma condição. Existem três formas de utilizá-lo:</p>
						<br>
						<p>for i := 0; i ^ n; i++ { ... }: Repete o bloco de código enquanto a condição "i ^ n" for verdadeira. A cada iteração, o valor de "i" é incrementado em 1.</p>
						<br>
						<p>for i ^ n { ... }: Repete o bloco de código enquanto a condição "i ^ n" for verdadeira. O valor de "i" deve ser inicializado antes do loop.</p>
						<br>
                        <p>for { ... }: Repete o bloco de código indefinidamente até que seja explicitamente interrompido com uma declaração "break" ou "return"</p>
                        <br>
						<h3>CONDICIONAIS</h3>
						<p>A estrutura "if" é utilizada para executar um bloco de código se uma determinada condição for verdadeira. Ela pode ser seguida por uma ou várias cláusulas "else if" opcionais, que permitem verificar condições adicionais, e uma cláusula "else" opcional para executar um bloco de código caso nenhuma das condições anteriores seja verdadeira.</p>
                        <br>
                        <p>if idade >= 18 {<br>
                            fmt.Println("Você é maior de idade.") <br>
                        } else if idade >= 13 { <br>
                            fmt.Println("Você é um adolescente.") <br>
                        } else { <br>
                            fmt.Println("Você é uma criança.") <br>
                        }</p>
                        <br>
						<h3>FLUXO</h3>
						<p>A estrutura "switch" permite avaliar uma expressão e executar um bloco de código com base em diferentes casos. Cada caso é comparado com o valor da expressão e, se houver correspondência, o bloco de código correspondente é executado. É possível utilizar a cláusula "default" para executar um bloco de código caso nenhum dos casos anteriores seja correspondido</p>
                        <br>
                        <p>switch diaDaSemana { <br>
                            case "segunda-feira": <br>
                                fmt.Println("Hoje é segunda-feira.")  <br>
                            case "terça-feira": <br>
                                fmt.Println("Hoje é terça-feira.") <br>
                            case "quarta-feira": <br>
                                fmt.Println("Hoje é quarta-feira.")  <br>
                            case "quinta-feira": <br>
                                fmt.Println("Hoje é quinta-feira.") <br>
                            case "sexta-feira": <br>
                                fmt.Println("Hoje é sexta-feira.") <br>
                            default: <br> 
                                fmt.Println("Hoje é fim de semana.") <br>
                            }</p>
                            <br>
						<hr />

							<h2>VARIÁVEIS</h2>
						<h3>LOCAIS</h3>
						<p>As variáveis locais são declaradas dentro de uma função ou bloco de código específico e têm um escopo limitado a esse bloco. Elas podem ser declaradas usando a palavra-chave var seguida pelo nome da variável e seu tipo.</p>
						<h3>GLOBAIS</h3>
						<p>As variáveis globais são declaradas fora de qualquer função e podem ser
							acessadas de qualquer lugar dentro do pacote. É uma prática recomendada
							evitar o uso excessivo de variáveis globais, pois elas podem tornar o código
							menos legível e dificultar a manutenção.
						</p>
						<h3>CONSTANTES</h3>
						<p>As constantes são valores fixos que não podem ser alterados durante a
							execução do programa. Em Go, você pode declarar constantes usando a
							palavra-chave const</p>
						<h3>TIPOS BÁSICOS</h3>
						<p>Tipos básicos incluem variáveis como inteiros, números de ponto flutuante,
							strings, booleanos e outros. Você pode declarar uma variável com um tipo
							específico explicitamente</p>
						<h3>ATRIBUIÇÃO DE VALOR</h3>
						<p>Em Go, você pode atribuir um valor a uma variável usando o operador =. O
							tipo da variável é inferido automaticamente com base no valor atribuído</p>
						<hr />

							<h2>OPERADORES</h2>
                        <h3>aritméticos</h3>
						<p>Os operadores aritméticos em Go são usados para realizar operações
                            matemáticas básicas, como adição, subtração, multiplicação, divisão e
                            módulo</p>
                        <br>
                        <p>package   <br>
                            import "fmt" <br>
                            func main() { <br>
                            a := 10 <br>
                            b := 3 <br>
                            fmt.Println(a + b) // Soma: 13 <br>
                            fmt.Println(a - b) // Subtração: 7 <br>
                            fmt.Println(a * b) // Multiplicação: 30 <br>
                            fmt.Println(a / b) // Divisão: 3 <br>
                            fmt.Println(a % b) // Módulo: 1 <br>
                            } <br>
                            </p>
                            <br>

                        <h3>atribuição</h3>
						<p>Os operadores de atribuição são usados para atribuir valores a
                            variáveis. O operador básico é o sinal de igual (=), mas também existem
                            operadores de atribuição combinados, como +=, -=, *= e /=, que
                            realizam uma operação aritmética e atribuem o resultado à variável.</p>
                        <br>
                        <p>package main <br>
                            import "fmt" <br>
                            func main() { <br>
                            a := 5 <br>
                            b := 2 <br>
                            fmt.Println(a) // 5 <br>
                            a += b // Equivalente a: a = a + b <br>
                            fmt.Println(a) // 7 <br>
                            a -= b // Equivalente a: a = a - b <br>
                            fmt.Println(a) // 5 <br>
                            a *= b // Equivalente a: a = a * b <br>
                            fmt.Println(a) // 10 <br>
                            a /= b // Equivalente a: a = a / b <br>
                            fmt.Println(a) // 5 <br>
                            } <br>
                            </p>

                        <h3>comparação</h3>
						<p>Os operadores de comparação são usados para comparar valores e
                            retornam um resultado booleano (verdadeiro ou falso). Alguns
                            operadores de comparação comuns em Go são == (igual a), !=
                            (diferente de), ^ (menor que), > (maior que), ^= (menor ou igual a) e >=
                            (maior ou igual a).</p>
                            <br>
                            <p>package main <br>
                                import "fmt" <br>
                                func main() { <br>
                                a := 5 <br>
                                b := 3 <br>
                                fmt.Println(a == b) // Igual a: false <br>
                                fmt.Println(a != b) // Diferente de: true <br>
                                fmt.Println(a ^ b) // Menor que: false <br>
                                fmt.Println(a > b) // Maior que: true <br>
                                fmt.Println(a ^= b) // Menor ou igual a: false <br>
                                fmt.Println(a >= b) // Maior ou igual a: true <br>
                                }</p>
                                <br>

                        <h3>lógicos</h3>
						<p>Os operadores lógicos em Go são usados para combinar ou negar
                            expressões booleanas. Os operadores lógicos mais comuns são && (E
                            lógico), || (OU lógico) e ! (NÃO lógico).</p>
                            <br>
                            <p>
                                package main  <br>
                                import "fmt" <br>
                                func main() { <br>
                                a := true <br>
                                b := false <br>
                                fmt.Println(a && b) // E lógico: false <br>
                                fmt.Println(a || b) // OU lógico: true <br>
                                fmt.Println(!a) // NÃO lógico: false <br>
                                } 
                            </p>
                            <br>
						<hr />

							<h2>TIPOS DE DADOS</h2>
						<h3>Inteiros</h3>
						<p>O GoLang suporta uma variedade de tipos de dados inteiros, incluindo int8, int16,
							int32 e int64, que representam inteiros com sinal, e uint8, uint16, uint32 e uint64, que
							representam inteiros sem sinal. Além disso, existe o tipo int, cujo tamanho varia de acordo
							com a arquitetura do sistema.</p>
						<br>
						<h3>Ponto flutuante</h3>
						<p>O Go possui dois tipos de ponto flutuante: float32 e float64, que
							representam números reais de precisão simples e dupla, respectivamente. O tipo float32 é
							usado para números de ponto flutuante com precisão simples, enquanto o float64 é usado
							para números de ponto flutuante com precisão dupla</p>
						<br>
						<h3>Booleanos</h3>
						<p>O tipo bool é usado para representar valores booleanos, que podem ser true
							(verdadeiro) ou false (falso). Esses valores são comumente usados em expressões
							condicionais e tomadas de decisão</p>
						<br>
						<h3>Strings</h3>
						<p>O tipo string é usado para representar sequências de caracteres. As strings são
							imutáveis no GoLang, o que significa que uma vez criadas, não podem ser alteradas. O
							GoLang oferece suporte a uma variedade de operações e funções para manipular strings de
							forma eficiente</p>
						<br>
						<h3>Arrays</h3>
						<p>Um array é uma coleção fixa de elementos do mesmo tipo. No GoLang, a sintaxe
							para declarar um array é [tamanho]tipo, onde "tamanho" é o número de elementos que o
							array pode armazenar e "tipo" é o tipo dos elementos do array. Por exemplo, var numeros
							[5]int declara um array de inteiros com tamanho 5.
							</p>
						<br>
						<h3>Slices</h3>
						<p>Os slices são estruturas de dados dinâmicas semelhantes a arrays, mas com
							tamanho flexível. Eles são construídos em cima de arrays e fornecem uma interface mais
							conveniente para manipulação de dados. Os slices são declarados usando a sintaxe []tipo</p>
						<br>
						<h3>Mapas</h3>
						<p>Os mapas são uma coleção de pares chave-valor, onde cada chave é exclusiva.
							Eles são implementados como tabelas de hash e são usados para armazenar e recuperar
							valores com base em suas chaves. A sintaxe para declarar um mapa é
							map[tipoChave]tipoValor</p>
						<br>
						<h3>Structs</h3>
						<p>Os structs são tipos de dados personalizados que permitem agrupar diferentes tipos
							de dados relacionados em uma única entidade. Eles são compostos por campos, cada um
							com um nome e um tipo. Os structs são úteis para modelar objetos e suas propriedades</p>
						<br>
						<hr />

							<h2>FUNÇÕES</h2>
						<p>No GoLang, as funções são blocos de código que executam uma tarefa específica. Elas são
							fundamentais para a modularização e reutilização de código. Aqui está um exemplo de
							como criar uma função no GoLang</p>
						<p>
							func nomeDaFuncao(parametro1 tipo, parametro2 tipo) tipoDeRetorno <br>
							{ <br>
							// Corpo da função <br>
							// Código a ser executado <br>
							return valorDeRetorno <br>
							} <br>
							Vamos entender os elementos acima: <br>

						</p>
						<p>func: A palavra-chave "func" é usada para declarar uma função no GoLang.
							nomeDaFuncao: É o nome que você escolhe para sua função. Ele deve seguir as regras de
							nomenclatura do GoLang.
							parametro1, parametro2: São os parâmetros que a função recebe. Você pode especificar
							zero ou mais parâmetros, cada um com um nome e um tipo.
							tipoDeRetorno: É o tipo de dado que a função retorna. Pode ser um tipo básico (como int,
							string, bool) ou um tipo personalizado (struct, slice, mapa).
							valorDeRetorno: É o valor que a função retorna. O tipo desse valor deve ser compatível com
							o tipoDeRetorno especificado.
							Aqui está um exemplo prático de uma função em GoLang que calcula a soma de dois
							números inteiros: 
						</p>
						<p>func soma(a int, b int) int { <br>
							resultado := a + b <br>
							return resultado <br>
							} <br>
						</p>
						<p>Neste exemplo, a função soma recebe dois parâmetros do tipo int (a e b) e retorna um valor
							do tipo int. O corpo da função realiza a soma dos dois números e retorna o resultado <br>
							Para chamar a função, você pode atribuir o valor de retorno a uma variável ou usá-la
							diretamente:
						</p>
						<p>resultadoSoma := soma(2, 3) <br>
							fmt.Println(resultadoSoma) // Imprime: 5 <br>
							ou <br>
							fmt.Println(soma(2, 3)) // Imprime: 5 <br>
						</p>
						<p>No GoLang, você também pode retornar múltiplos valores em uma função, simplesmente
							especificando os tipos de retorno separados por vírgula. Por exemplo: <br> <br>
							func dividir(a, b float64) (float64, error) { <br>
							if b == 0 { <br>
							return 0, errors.New("Divisão por zero não é permitida") <br>
							} <br>
							resultado := a / b <br>
							return resultado, nil <br>
							} <br> <br>
							Neste exemplo, a função dividir retorna um valor do tipo float64 e um valor do tipo error. O
							segundo valor é usado para indicar se ocorreu algum erro durante a execução da função.
							</p>
						<hr />

							<h2>ARRAYS</h2>
						<p>No GoLang, os arrays são estruturas de dados que armazenam um número fixo de
							elementos do mesmo tipo. Aqui está um exemplo de como criar e trabalhar com arrays no
							GoLang:</p>
						<p>go <br>
							func main() { <br>
							// Declaração e inicialização de um array de inteiros com tamanho 5 <br>
							var numeros [5]int <br> <br>
							// Atribuição de valores aos elementos do array <br>
							numeros[0] = 10 <br>
							numeros[1] = 20 <br>
							numeros[2] = 30 <br>
							numeros[3] = 40 <br>
							numeros[4] = 50 <br> <br>
							// Acessando e imprimindo os valores do array <br>
							fmt.Println(numeros[0]) // Imprime: 10 <br>
							fmt.Println(numeros[2]) // Imprime: 30 <br>
							fmt.Println(numeros) // Imprime: [10 20 30 40 50] <br> <br>
							// Declaração e inicialização de um array de strings <br>
							nomes := [3]string{"João", "Maria", "Pedro"} <br>
							// Imprimindo os valores do array de strings <br>
							fmt.Println(nomes[0]) // Imprime: João <br>
							fmt.Println(nomes[1]) // Imprime: Maria <br>
							fmt.Println(nomes[2]) // Imprime: Pedro <br>
							} <br>
							</p>
							<p>No exemplo acima, um array de inteiros chamado `numeros` é declarado com tamanho 5.
								Em seguida, os valores são atribuídos aos elementos do array usando o índice do elemento
								(começando do índice 0). O acesso aos valores é feito utilizando o nome do array seguido
								pelo índice entre colchetes.
								</p>
							<p>Outro exemplo mostra a declaração e inicialização de um array de strings chamado
								`nomes`, utilizando a sintaxe curta `:=` para inferir o tipo de dados e atribuir valores
								diretamente</p>
							<p>Os arrays em GoLang têm um tamanho fixo e não podem ser alterados após a criação. Se
								você precisar de uma estrutura de dados com tamanho flexível, pode usar slices, que são
								construídos em cima de arrays.</p>
							<p>Você também pode usar loops, como o loop `for`, para iterar sobre os elementos de um
								array</p>
							<p>
								go <br>
								func main() { <br>
								numeros := [5]int{10, 20, 30, 40, 50} <br>
								// Iterando sobre os elementos do array <br>
								for i := 0; i ^ len(numeros); i++ { <br>
								fmt.Println(numeros[i])  <br>
								} <br>
								} <br>
							</p>
							<p>Nesse exemplo, o loop `for` é usado para iterar sobre os elementos do array `numeros` e
								imprimir seus valores.
								</p>
							<p>Essas são as noções básicas sobre como criar e trabalhar com arrays no GoLang.
								Lembre-se de que os slices oferecem mais flexibilidade em relação ao tamanho, mas os
								arrays são úteis quando você precisa de uma coleção com tamanho fixo.</p>
						<hr />
					</div>
				</div>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<div class="inner">
					<div class="content">
						<section>
							<h3>PROJETO</h3>
							<p>Todo o projeto apresentado, incluindo o site e as video aulas, além, lógicamente de todo o conteúdo educacional, foi produzido e disponibilizado pelos alunos integrantes do grupo. O mesmo é baseado em cursos de programação e artigos encontrados na internet.</p>
						</section>
						<section>
							<h4>INTEGRANTES</h4>
							<ul class="alt">
								<li><a href="https://www.instagram.com/damxsceno/">Miguel Damasceno Santos</a></li>
								<li><a href="https://www.instagram.com/theobaruel/">Theo Nakaya Baruel</a></li>
								<li><a href="https://www.instagram.com/joaovitor__ramos/">João Vitor Fonseca</a></li>
							</ul>
						</section>
						<section>
							<h4>REDES SOCIAIS</h4>
							<ul class="plain">
								<li><a href="#"><i class="icon fa-twitter">&nbsp;</i>Twitter</a></li>
								<li><a href="#"><i class="icon fa-instagram">&nbsp;</i>Instagram</a></li>
								<li><a href="#"><i class="icon fa-github">&nbsp;</i>Github</a></li>
							</ul>
						</section>
					</div>
					<div class="copyright">
						&copy; Todos direitos reservados à sala do Terceiro ano de Automação - CTIG UNESP</a>.
					</div>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>